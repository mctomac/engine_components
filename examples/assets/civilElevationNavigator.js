var A=Object.defineProperty;var B=(e,t,o)=>t in e?A(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var v=(e,t,o)=>(B(e,typeof t!="symbol"?t+"":t,o),o);import"./web-ifc-api-BC8YMRiS.js";import{f as C,p as D,s as K,n as E,N as I,u as N}from"./index-BmA4XTIx.js";import{p as x}from"./index-DyM33b1I.js";import{Z as H,C as $}from"./index-C5Kx38b6.js";import{S as F}from"./stats.min-GTpOrGrX.js";import{a as R,b as T,C as U}from"./index-Bmso1r6C.js";import{R as W}from"./renderer-with-2d-k8_K2aYf.js";import"./import-wrapper-prod-LhqN7JJy.js";import"./Line2-7GsqoD5b.js";import"./mark--YNYmWZ2.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./index-B5B6dldk.js";const S=class S extends R{constructor(o){super(o);v(this,"view","vertical");v(this,"enabled",!0);this.components.add(S.uuid,this)}get world(){return super.world}set world(o){this.world!==o&&(super.world=o,this._highlighter&&this._highlighter.onSelect.add(g=>{if(!this.world)throw new Error("A world is needed to work with this component!");const s=this.components.get(T);s.deleteByType(["Slope","Height","InitialKPV","FinalKPV"]);const{alignment:r}=g.curve,d=[];for(const a of r.vertical){const f=a.mesh.geometry.attributes.position.array;d.push(f)}const{defSegments:p,slope:w}=this.setDefSegments(d),u=this.world.scene.three;for(let a=0;a<r.vertical.length;a++){const f=r.vertical[a];s.addVerticalMarker(this.world,`S: ${w[a].slope}%`,f.mesh,"Slope",u),s.addVerticalMarker(this.world,`H: ${p[a].end.y.toFixed(2)}`,f.mesh,"Height",u)}s.addVerticalMarker(this.world,"KP: 0",r.vertical[0].mesh,"InitialKPV",u),s.addVerticalMarker(this.world,`KP: ${r.vertical.length}`,r.vertical[r.vertical.length-1].mesh,"FinalKPV",u)}))}};v(S,"uuid","097eea29-2d5a-431a-a247-204d44670621");let M=S;x.init();H.init();const V=document.getElementById("container"),n=new C,L=n.get(D),i=L.create();i.scene=new K(n);i.renderer=new W(n,V);i.camera=new E(n);n.init();i.scene.setup();i.camera.controls.setLookAt(5,5,5,0,0,0);V.appendChild(i.renderer.three2D.domElement);const Z=n.get(I);Z.create(i);const z=n.get(N),_=await fetch("https://thatopen.github.io/engine_components/resources/road.frag"),j=await _.arrayBuffer(),q=new Uint8Array(j),k=z.load(q);i.scene.three.add(k);const l=new $(n);l.world=i;l.draw(k);l.highlighter.hoverCurve.material.color.set(1,1,1);const{material:y}=l.highlighter.hoverPoints;if(Array.isArray(y)){const e=y[0];"color"in e&&e.color.set(1,1,1)}else"color"in y&&y.color.set(1,1,1);const P=document.getElementById("scene-2d-left");P.components=n;if(!P.world)throw new Error("World not found!");const b=new U(n);b.world=P.world;b.draw(k);const c=document.getElementById("scene-2d-right");c.components=n;if(!c.world)throw new Error("World not found!");const h=new M(n);h.world=c.world;h.draw(k);b.onMarkerChange.add(({alignment:e,percentage:t})=>{h.setMarker(e,t,"hover"),l.setMarker(e,t,"hover")});b.onHighlight.add(({mesh:e,point:t})=>{const{index:o,alignment:g}=e.curve,s=g.getPercentageAt(t,"horizontal");if(s===null)return;const{curve:r}=g.getCurveAt(s,"vertical");if(h.highlighter.select(r.mesh),h.setMarker(r.alignment,s,"select"),c.world){r.mesh.geometry.boundingSphere||r.mesh.geometry.computeBoundingSphere();const w=r.mesh.geometry.boundingSphere.clone();w.radius*=1.5,c.world.camera.controls.fitToSphere(w,!0)}l.highlighter.select(e);const d=e.curve.alignment.absolute[o];d.mesh.geometry.computeBoundingSphere();const p=d.mesh.geometry.boundingSphere;p&&i.camera.controls.fitToSphere(p,!0)});const m=new F;m.showPanel(2);document.body.append(m.dom);m.dom.style.left="0px";i.renderer.onBeforeUpdate.add(()=>m.begin());i.renderer.onAfterUpdate.add(()=>m.end());
