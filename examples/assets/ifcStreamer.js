var J=Object.defineProperty;var K=(C,x,e)=>x in C?J(C,x,{enumerable:!0,configurable:!0,writable:!0,value:e}):C[x]=e;var d=(C,x,e)=>(K(C,typeof x!="symbol"?x+"":x,e),e);import{d as X,B as $,j as S,a as j,N as z,G as Q,C as O,X as Z,k as q,c as ee,e as H}from"./web-ifc-api-BC8YMRiS.js";import{S as te}from"./stats.min-GTpOrGrX.js";import{g as se}from"./lil-gui.module.min-Bc0DeA9g.js";import{Y as oe,K as ie,J as ne,U as R,u as L,b as re,f as ae,p as de,s as ce,i as le,k as me,N as fe}from"./index-BmA4XTIx.js";import{D as he}from"./import-wrapper-prod-LhqN7JJy.js";import"./_commonjsHelpers-Cpj98o6Y.js";class ge extends oe{constructor(e,t,o){super(e,t,o);d(this,"threshold",50);d(this,"bboxThreshold",200);d(this,"maxLostTime",3e4);d(this,"maxHiddenTime",5e3);d(this,"boxes",new Map);d(this,"_geometry");d(this,"_material",new X({transparent:!0,side:2,opacity:1}));d(this,"onViewUpdated",new ie);d(this,"_modelIDIndex",new Map);d(this,"_indexModelID",new Map);d(this,"_nextModelID",0);d(this,"_geometries",new Map);d(this,"_geometriesGroups",new Map);d(this,"_foundGeometries",new Set);d(this,"_intervalID",null);d(this,"codes",new Map);d(this,"handleWorkerMessage",async e=>{const t=e.data.colors,o={},s={},i={},r={},a=performance.now();let c=!1;const f=new Set(this._foundGeometries);for(const[h,p]of t){const n=this._geometries.get(h);if(!n)continue;const g=p>this.threshold,{exists:u}=n;if(!g&&!u)continue;const m=this._indexModelID.get(n.modelIndex);f.delete(h),g&&u?(n.time=a,r[m]||(r[m]=new Set),r[m].add(n.geometryID),this._foundGeometries.add(h),c=!0):g&&!u?(o[m]||(o[m]=new Map),n.time=a,n.exists=!0,o[m].has(p)||o[m].set(p,new Set),o[m].get(p).add(n.geometryID),this._foundGeometries.add(h),c=!0):!g&&u&&(this.handleLostGeometries(a,h,n,s,i),c=!0)}c&&await this.onViewUpdated.trigger({toLoad:o,toRemove:s,toHide:i,toShow:r}),this._isWorkerBusy=!1});this.updateInterval=500,this._geometry=new $(1,1,1),this._geometry.groups=[],this._geometry.deleteAttribute("uv");const s=this._geometry.attributes.position.array;for(let i=0;i<s.length;i++)s[i]+=.5;this._geometry.attributes.position.needsUpdate=!0,this.worker.addEventListener("message",this.handleWorkerMessage),this.autoUpdate&&(this._intervalID=window.setInterval(this.updateVisibility,this.updateInterval))}dispose(){super.dispose(),this.onViewUpdated.reset(),this._intervalID!==null&&(window.clearInterval(this._intervalID),this._intervalID=null);for(const[e,t]of this._geometriesGroups){t.removeFromParent();const o=[...t.children];for(const s of o)s.removeFromParent()}this._geometriesGroups.clear();for(const[e,t]of this.boxes)t.dispose(!0);this.boxes.clear();for(const[e,t]of this._geometries)t.fragment&&(t.fragment.dispose(!0),t.fragment=void 0);this._geometries.clear(),this._geometry.dispose(),this._material.dispose(),this._modelIDIndex.clear(),this._indexModelID.clear(),this.codes.clear()}add(e,t,o){const s=this.createModelIndex(e),i=S.enabled;S.enabled=!1;const r=new Map,a=new j,c=new z(this._geometry,this._material,10);this.boxes.set(s,c),this.scene.add(c.mesh);const f=new Q;this.scene.add(f),this._geometriesGroups.set(s,f);const h=new Map;for(const n of t)for(const g of n.geometries){const{geometryID:u,transformation:m,color:l}=g,_=new O;_.setRGB(l[0],l[1],l[2],"srgb");const w=this.getInstanceID(n.id,u),D=o[u];if(!D){console.log(`Geometry not found: ${u}`);continue}const{boundingBox:F}=D;let y;r.has(u)?y=r.get(u):(y=this.getAvailableColor(),this.increaseColor(),r.set(u,y));const{r:G,g:b,b:M,code:I}=y,E=new O;E.setRGB(G/255,b/255,M/255,"srgb"),this.codes.has(s)||this.codes.set(s,new Map),this.codes.get(s).set(u,I);const V=new j,P=Object.values(F);if(V.fromArray(m),a.fromArray(P),V.multiply(a),h.has(w)){const v=h.get(w);if(v===void 0||!v.colors)throw new Error("Malformed item!");v.colors.push(E),v.geometryColors.push(_),v.transforms.push(V)}else h.set(w,{id:w,colors:[E],geometryColors:[_],transforms:[V]});if(this._geometries.has(I))this._geometries.get(I).assetIDs.add(n.id);else{const v=new Set([n.id]);this._geometries.set(I,{modelIndex:s,geometryID:u,assetIDs:v,exists:!1,hidden:!1,time:0})}}const p=Array.from(h.values());c.add(p),S.enabled=i}remove(e){const t=this._modelIDIndex.get(e);if(t===void 0)throw new Error("Model doesn't exist!");const o=this._geometriesGroups.get(t);o.removeFromParent();const s=[...o.children];for(const a of s)a.removeFromParent();this._geometriesGroups.delete(t),this.boxes.get(t).dispose(!1),this.boxes.delete(t);const r=this.codes.get(t);this.codes.delete(t);for(const[a,c]of r){const f=this._geometries.get(c);f&&f.fragment&&(f.fragment.dispose(!1),f.fragment=void 0),this._geometries.delete(c)}this._modelIDIndex.delete(e),this._indexModelID.delete(t),this._foundGeometries.clear()}addFragment(e,t,o){const s=S.enabled;S.enabled=!1;const i=this._modelIDIndex.get(e),a=this.codes.get(i).get(t),c=this._geometries.get(a);if(this.setGeometryVisibility(c,!1,!1),!c.fragment){c.fragment=new z(o.mesh.geometry,this._material,o.capacity);const g=this._geometriesGroups.get(i);if(!g)throw new Error("Group not found!");g.add(c.fragment.mesh)}const[f,h,p]=a.split("-").map(g=>parseInt(g,10)),n=[];for(const g of o.ids){const u=o.get(g);if(!u.colors)throw new Error("Malformed fragments!");for(const m of u.colors)m.setRGB(f/255,h/255,p/255,"srgb");n.push(u)}c.fragment.add(n),S.enabled=s,this.needsUpdate=!0}removeFragment(e,t){const o=this._modelIDIndex.get(e),i=this.codes.get(o).get(t),r=this._geometries.get(i);if(r.hidden||this.setGeometryVisibility(r,!0,!1),r.fragment){const{fragment:a}=r;a.dispose(!1),r.fragment=void 0}}setModelTransformation(e,t){const o=this._modelIDIndex.get(e);if(o===void 0)throw new Error("Model not found!");const s=this.boxes.get(o);s&&(s.mesh.position.set(0,0,0),s.mesh.rotation.set(0,0,0),s.mesh.scale.set(1,1,1),s.mesh.applyMatrix4(t));const i=this._geometriesGroups.get(o);i&&(i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),i.applyMatrix4(t))}setVisibility(e,t,o){const s=this._modelIDIndex.get(t);if(s!==void 0)for(const[i,r]of o){const a=this.codes.get(s);if(a===void 0)throw new Error("Map not found!");const c=a.get(i),f=this._geometries.get(c);if(f===void 0)throw new Error("Geometry not found!");f.hidden=!e,this.setGeometryVisibility(f,e,!0,r)}}setGeometryVisibility(e,t,o,s){const{modelIndex:i,geometryID:r,assetIDs:a}=e,c=this.boxes.get(i);if(c===void 0)throw new Error("Model not found!");const f=s||a;if(o&&e.fragment)e.fragment.setVisibility(t,f);else{const h=new Set;for(const p of f){const n=this.getInstanceID(p,r);h.add(n)}c.setVisibility(t,h)}}handleLostGeometries(e,t,o,s,i){const r=this._indexModelID.get(o.modelIndex),a=e-o.time;a>this.maxLostTime?(s[r]||(s[r]=new Set),o.exists=!1,s[r].add(o.geometryID),this._foundGeometries.delete(t)):a>this.maxHiddenTime&&(i[r]||(i[r]=new Set),i[r].add(o.geometryID))}createModelIndex(e){if(this._modelIDIndex.has(e))throw new Error("Can't load the same model twice!");const t=this._nextModelID;return this._nextModelID++,this._modelIDIndex.set(e,t),this._indexModelID.set(t,e),t}getInstanceID(e,t){const s=10**(Math.log(t)*Math.LOG10E+1|0);return e+t/s}}class ue extends he{constructor(){super("MyAppDatabase");d(this,"files");this.version(1).stores({files:"id, file"})}}const k=class k extends ne{constructor(e){super(e);d(this,"enabled",!0);d(this,"onFragmentsDeleted",new R);d(this,"onFragmentsLoaded",new R);d(this,"onDisposed",new R);d(this,"models",{});d(this,"serializer",new Z);d(this,"maxRamTime",5e3);d(this,"useCache",!0);d(this,"_culler",null);d(this,"_world",null);d(this,"_ramCache",new Map);d(this,"_fileCache",new ue);d(this,"_url",null);d(this,"_isDisposing",!1);d(this,"_geometryInstances",{});d(this,"_loadedFragments",{});d(this,"fragIDData",new Map);d(this,"_baseMaterial",new q);d(this,"_baseMaterialT",new q({transparent:!0,opacity:.5}));this.components.add(k.uuid,this)}get url(){if(!this._url)throw new Error("url must be set before using the streaming service!");return this._url}set url(e){this._url=e}get world(){if(!this._world)throw new Error("You must set a world before using the streamer!");return this._world}set world(e){var t;this._world=e,(t=this._culler)==null||t.dispose(),this._culler=new ge(this.components,e),this._culler.onViewUpdated.add(async({toLoad:o,toRemove:s,toShow:i,toHide:r})=>{await this.loadFoundGeometries(o),await this.unloadLostGeometries(s),this.setMeshVisibility(i,!0),this.setMeshVisibility(r,!1)})}get culler(){if(!this._culler)throw new Error("You must set a world before using the streamer!");return this._culler}dispose(){var e;this._isDisposing=!0,this.onFragmentsLoaded.reset(),this.onFragmentsDeleted.reset(),this._ramCache.clear(),this.models={},this._geometryInstances={},this._loadedFragments={},this.fragIDData.clear(),this._baseMaterial.dispose(),this._baseMaterialT.dispose(),(e=this._culler)==null||e.dispose(),this.onDisposed.trigger(k.uuid),this.onDisposed.reset(),this._isDisposing=!1}async load(e,t,o){const{assets:s,geometries:i,globalDataFileId:r}=e,a=this.url+r,f=await(await fetch(a)).arrayBuffer(),h=new Uint8Array(f),n=this.components.get(L).load(h,{coordinate:t});this.world.scene.three.add(n);const{opaque:g,transparent:u}=n.geometryIDs;for(const[l,_]of g){const w=n.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[n,l,new Set])}for(const[l,_]of u){const w=n.keyFragments.get(_);if(w===void 0)throw new Error("Malformed fragments group!");this.fragIDData.set(w,[n,Math.abs(l),new Set])}this.culler.add(n.uuid,s,i),this.models[n.uuid]={assets:s,geometries:i};const m=new Map;for(const l of s){const _=l.id;for(const{transformation:w,geometryID:D,color:F}of l.geometries){m.has(D)||m.set(D,[]);const y=m.get(D);if(!y)throw new Error("Malformed instances");y.push({id:_,transformation:w,color:F})}}if(this._geometryInstances[n.uuid]=m,o){const l=new Map,_=new Map;for(const b in o.ids){const M=o.ids[b],I=parseInt(b,10);l.set(I,M)}for(const b in o.types){const M=o.types[b],I=parseInt(b,10);_.set(I,M)}const w=r.replace("-global","-properties");n.streamSettings={baseUrl:this.url,baseFileName:w,ids:l,types:_};const{indexesFile:D}=o,y=await(await fetch(this.url+D)).text(),G=this.components.get(re);G.setRelationMap(n,G.getRelationsMapFromJSON(y))}return this.culler.needsUpdate=!0,n}remove(e){this._isDisposing=!0;const o=this.components.get(L).groups.get(e);if(o===void 0){console.log("Group to delete not found.");return}delete this.models[e],delete this._geometryInstances[e],delete this._loadedFragments[e];const s=o.keyFragments.values();for(const i of s)this.fragIDData.delete(i);this.culler.remove(e),this._isDisposing=!1}setVisibility(e,t){const o=new Map;for(const s in t){const i=this.fragIDData.get(s);if(i===void 0)throw new Error("Geometry not found!");const[r,a,c]=i,f=r.uuid;o.has(f)||o.set(f,new Map);const h=o.get(f),p=t[s];for(const g of p)e?c.delete(g):c.add(g);h.get(a)||h.set(a,new Set);const n=h.get(a);for(const g of p)n.add(g)}for(const[s,i]of o){this.culler.setVisibility(e,s,i);for(const[r]of i){const a=this._loadedFragments[s];if(!a)continue;const c=a[r];if(c)for(const f of c){const h=t[f.id];h&&f.setVisibility(e,h)}}}this.culler.needsUpdate=!0}async clearCache(){await this._fileCache.delete()}get(){}update(){}async loadFoundGeometries(e){for(const t in e){if(this._isDisposing)return;const s=this.components.get(L).groups.get(t);if(!s)return;const{geometries:i}=this.models[t],r=new Map,a=new Set;for(const[p,n]of e[t])for(const g of n){a.add(g);const u=i[g];if(!u)throw new Error("Geometry not found");if(u.geometryFile){const m=u.geometryFile,l=r.get(m)||0;r.set(m,l+p)}}const c=Array.from(r).sort((p,n)=>n[1]-p[1]);for(const[p]of c){const n=this.url+p;if(!this._ramCache.has(n)){let m=new Uint8Array;if(this.useCache){const _=await this._fileCache.files.get(n);if(_)m=_.file;else{const D=await(await fetch(n)).arrayBuffer();m=new Uint8Array(D),this._fileCache.files.add({file:m,id:n})}}else{const w=await(await fetch(n)).arrayBuffer();m=new Uint8Array(w)}const l=this.serializer.import(m);this._ramCache.set(n,{data:l,time:performance.now()})}const g=this._ramCache.get(n);if(!g)continue;g.time=performance.now();const u=[];if(g)for(const[m,{position:l,index:_,normal:w}]of g.data){if(this._isDisposing)return;if(!a.has(m)||!this._geometryInstances[t]||!this._geometryInstances[t].has(m))continue;const F=this._geometryInstances[t].get(m);if(!F)throw new Error("Instances not found!");const y=new ee,G=new H(l,3),b=new H(w,3);y.setAttribute("position",G),y.setAttribute("normal",b),y.setIndex(Array.from(_));const M=[],I=[];for(const E of F)E.color[3]===1?I.push(E):M.push(E);this.newFragment(s,m,y,M,!0,u),this.newFragment(s,m,y,I,!1,u)}u.length&&!this._isDisposing&&this.onFragmentsLoaded.trigger(u)}const f=new Set,h=performance.now();for(const[p,{time:n}]of this._ramCache)h-n>this.maxRamTime&&f.add(p);for(const p of f)this._ramCache.delete(p)}}async unloadLostGeometries(e){if(this._isDisposing)return;const t=[],o=this.components.get(L);for(const s in e){const i=o.groups.get(s);if(!i)throw new Error("Fragment group not found!");if(!this._loadedFragments[s])continue;const r=this._loadedFragments[s],a=e[s];for(const c of a){if(this.culler.removeFragment(i.uuid,c),!r[c])continue;const f=r[c];for(const h of f)i.items.splice(i.items.indexOf(h),1),t.push(h);delete r[c]}}t.length&&this.onFragmentsDeleted.trigger(t);for(const s of t)o.list.delete(s.id),this.world.meshes.delete(s.mesh),s.mesh.material=[],s.dispose(!0)}setMeshVisibility(e,t){for(const o in e)for(const s of e[o]){const i=this._loadedFragments[o];if(!i)continue;const r=i[s];if(r)for(const a of r)a.mesh.visible=t}}newFragment(e,t,o,s,i,r){if(s.length===0||this._isDisposing)return;const a=e.geometryIDs,c=i?a.transparent:a.opaque,h=t*(i?-1:1),p=c.get(h);if(p===void 0)return;const n=e.keyFragments.get(p);if(n===void 0)return;const g=this.components.get(L);if(g.list.has(n))return;const m=i?this._baseMaterialT:this._baseMaterial,l=new z(o,m,s.length);l.id=n,l.mesh.uuid=n,l.group=e,e.add(l.mesh),e.items.push(l),g.list.set(l.id,l),this.world.meshes.add(l.mesh),this._loadedFragments[e.uuid]||(this._loadedFragments[e.uuid]={});const _=this._loadedFragments[e.uuid];_[t]||(_[t]=[]),_[t].push(l);const w=new Map;for(let G=0;G<s.length;G++){const b=new j,M=new O,{id:I,transformation:E,color:Y}=s[G];b.fromArray(E);const[V,P,v]=Y;if(M.setRGB(V,P,v,"srgb"),w.has(I)){const N=w.get(I);if(!N)continue;N.transforms.push(b),N.colors&&N.colors.push(M)}else w.set(I,{id:I,colors:[M],transforms:[b]})}const D=Array.from(w.values());l.add(D);const F=this.fragIDData.get(l.id);if(!F)throw new Error("Fragment data not found!");const y=F[2];y.size&&l.setVisibility(!1,y),this.culler.addFragment(e.uuid,t,l),r.push(l)}};d(k,"uuid","22437e8d-9dbc-4b99-a04f-d2da280d50c8");let W=k;const pe=document.getElementById("container"),B=new ae,we=B.get(de),A=we.create();A.scene=new ce(B);A.renderer=new le(B,pe);A.camera=new me(B);B.init();A.scene.setup();A.camera.controls.setLookAt(12,6,8,0,0,-10);const _e=B.get(fe);_e.create(A);const U=new W(B);U.world=A;U.url="https://thatopen.github.io/engine_components/resources/streaming/";async function ye(C,x){const t=await(await fetch(C)).json();let o;o=await(await fetch(x)).json();const s=await U.load(t,!0,o);console.log(s);const i=await s.getProperties(186);console.log(i)}await ye("https://thatopen.github.io/engine_components/resources/streaming/small.ifc-processed.json","https://thatopen.github.io/engine_components/resources/streaming/small.ifc-processed-properties.json");A.camera.controls.addEventListener("sleep",()=>{U.culler.needsUpdate=!0});U.useCache=!0;async function Ie(){await U.clearCache(),window.location.reload()}U.culler.threshold=10;U.culler.maxHiddenTime=1e3;U.culler.maxLostTime=4e4;const De=new se,be={clearCache:Ie};De.add(be,"clearCache");const T=new te;T.showPanel(2);document.body.append(T.dom);T.dom.style.left="0px";A.renderer.onBeforeUpdate.add(()=>T.begin());A.renderer.onAfterUpdate.add(()=>T.end());
