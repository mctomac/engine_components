var j=Object.defineProperty;var W=(M,d,e)=>d in M?j(M,d,{enumerable:!0,configurable:!0,writable:!0,value:e}):M[d]=e;var P=(M,d,e)=>(W(M,typeof d!="symbol"?d+"":d,e),e);import{r as k,V as I,P as q,I as H,a as T,M as C,ap as J,L as K,s as O}from"./web-ifc-api-BC8YMRiS.js";import{S as Q}from"./stats.min-GTpOrGrX.js";import{C as X,a as Y,W as Z,S as _,b as ee,c as te}from"./index-B99Vyz6D.js";import{R as ne}from"./index-Cv1osOVr.js";import{G as se}from"./index-vdN6D13n.js";import{C as oe}from"./index-CQ204xoG.js";import{F as ae}from"./index-Cy4SZRUH.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"./async-event-D8tC9awa.js";const D=class D extends X{constructor(e){super(e);P(this,"enabled",!0);e.add(D.uuid,this)}getFace(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const h=new Map,n=e.geometry.index.array,{plane:o}=this.getFaceData(g,w,e),i=[];for(let c=0;c<n.length/3;c++){const{plane:p,edges:a}=this.getFaceData(c,w,e);if(p.equals(o)){i.push({index:c,edges:a});for(const{id:u,points:s,distance:x}of a)h.set(u,{points:s,distance:x})}}let y=0;const r=new Map,m=new Map;for(const{index:c,edges:p}of i){const a=new Map;for(const{id:t}of p)if(r.has(t)){const f=r.get(t);a.set(t,f)}const u=p.map(t=>t.id);if(!a.size){const t=y++;for(const{id:f}of p)r.set(f,t);m.set(t,{edges:new Set(u),indices:new Set([c])});continue}let s=null;const x=new Set,E=new Set(u);for(const[t,f]of a){s===null?s=f:f!==s&&x.add(f),r.delete(t);const{edges:z}=m.get(f);z.delete(t),E.delete(t)}if(s===null)throw new Error("Error computing face!");const v=m.get(s),{indices:$}=v;$.add(c);for(const t of E){r.set(t,s);const{edges:f}=v;f.add(t)}for(const t of x){const f=m.get(t),{edges:z,indices:R}=f,B=m.get(s),{edges:V,indices:U}=B;for(const S of z)V.add(S),r.set(S,s);for(const S of R)U.add(S);m.delete(t)}}for(const[c,{indices:p,edges:a}]of m)if(p.has(g)){const u=[];for(const s of a){const x=h.get(s);u.push(x)}return{edges:u,indices:p}}return null}static distanceFromPointToLine(e,g,w,h=!1){const n=new k,o=new I;return n.set(g,w),n.closestPointToPoint(e,h,o),o.distanceTo(e)}getFaceData(e,g,w){const h=this.getVerticesAndNormal(w,e,g),{p1:n,p2:o,p3:i,faceNormal:y}=h;this.round(n),this.round(o),this.round(i),this.round(y);const r=[{id:`${n.x}|${n.y}|${n.z}`,value:n},{id:`${o.x}|${o.y}|${o.z}`,value:o},{id:`${i.x}|${i.y}|${i.z}`,value:i}];r.sort((v,$)=>v.id<$.id?-1:v.id>$.id?1:0);const[{id:m,value:c},{id:p,value:a},{id:u,value:s}]=r,x=[{id:`${m}|${p}`,distance:c.distanceTo(a),points:[c,a]},{id:`${p}|${u}`,distance:a.distanceTo(s),points:[a,s]},{id:`${m}|${u}`,distance:c.distanceTo(s),points:[c,s]}],E=new q;return E.setFromNormalAndCoplanarPoint(y,n),E.constant=Math.round(E.constant*10)/10,{plane:E,edges:x}}getVerticesAndNormal(e,g,w){if(!e.geometry.index)throw new Error("Geometry must be indexed!");const h=e.geometry.index.array,n=e.geometry.attributes.position.array,o=e.geometry.attributes.normal.array,i=h[g*3]*3,y=h[g*3+1]*3,r=h[g*3+2]*3,m=new I(n[i],n[i+1],n[i+2]),c=new I(n[y],n[y+1],n[y+2]),p=new I(n[r],n[r+1],n[r+2]),a=new I(o[i],o[i+1],o[i+2]),u=new I(o[y],o[y+1],o[y+2]),s=new I(o[r],o[r+1],o[r+2]),x=(a.x+u.x+s.x)/3,E=(a.y+u.y+s.y)/3,v=(a.z+u.z+s.z)/3,$=new I(x,E,v);if(w!==void 0&&e instanceof H){const t=new T;e.getMatrixAt(w,t);const f=new T;f.extractRotation(t),$.applyMatrix4(f),m.applyMatrix4(t),c.applyMatrix4(t),p.applyMatrix4(t)}return{p1:m,p2:c,p3:p,faceNormal:$}}round(e){e.x=Math.trunc(e.x*1e3)/1e3,e.y=Math.trunc(e.y*1e3)/1e3,e.z=Math.trunc(e.z*1e3)/1e3}};P(D,"uuid","267ca032-672f-4cb0-afa9-d24e904f39d6");let L=D;const re=document.getElementById("container"),F=new Y,ce=F.get(Z),l=ce.create();l.scene=new _(F);l.renderer=new ee(F,re);l.camera=new te(F);F.init();l.camera.controls.setLookAt(12,6,8,0,0,-10);l.scene.setup();const de=F.get(se);de.create(l);const ie=new ae(F),fe=await fetch("https://thatopen.github.io/engine_components/resources/small.frag"),le=await fe.arrayBuffer(),ge=new Uint8Array(le),A=ie.load(ge);l.scene.three.add(A);const pe=F.get(oe),N=pe.create(l);for(const M of A.children)M instanceof C&&N.add(M);N.needsUpdate=!0;l.camera.controls.addEventListener("sleep",()=>{N.needsUpdate=!0});const ue=F.get(L),me=F.get(ne),we=me.get(l),G=new J,ye=new K({color:16711680,depthTest:!1}),he=new O(G,ye);l.scene.three.add(he);l.renderer&&l.renderer.three.domElement.addEventListener("mousemove",()=>{const d=we.castRay([A]);if(!d||!(d.object instanceof C)||d.faceIndex===void 0)return;const e=ue.getFace(d.object,d.faceIndex,d.instanceId);if(e){const g=[];for(const w of e.edges)g.push(...w.points);G.setFromPoints(g)}});const b=new Q;b.showPanel(2);document.body.append(b.dom);b.dom.style.left="0px";b.dom.style.right="auto";l.renderer.onBeforeUpdate.add(()=>b.begin());l.renderer.onAfterUpdate.add(()=>b.end());
